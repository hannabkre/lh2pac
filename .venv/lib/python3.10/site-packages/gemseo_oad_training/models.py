# Copyright 2024 ENAC
# Copyright 2021 IRT Saint Exupéry, https://www.irt-saintexupery.com
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License version 3 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program; if not, write to the Free Software Foundation,
# Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
# :author: Conceptual Airplane Design & Operations (CADO team, ENAC)
#          Thierry DRUOT
# Code improvements:
#          François Gallard
#          Matthias De Lozzo
#          IRT Saint Exupéry
"""Disciplinary models."""

from typing import Literal

import numpy as np
from scipy.integrate import solve_ivp

from gemseo_oad_training import unit

ENGINE_TYPES = Literal["electrofan", "turbofan"]
"""The engine types."""

FUEL_TYPES = Literal["battery", "kerosene", "liquid_h2"]
"""The fuel types."""

ODE_TYPES = Literal["breguet", "ivp"]
"""The ODE types."""


def _raise_fuel_type_error() -> None:
    """Raise a ValueError because of a wrong fuel type."""
    msg = "fuel_type must be 'kerosene', 'liquid_h2' or 'battery'."
    raise ValueError(msg)


def geometry(
    fuel_type: str = "kerosene",
    n_pax: float = 150.0,
    area: float = 114.0,
    ar: float = 9.0,
    tkl: float = 2.75,
    vi: float = 0.8,
) -> tuple[float, float, float]:
    """Compute the geometrical data.

    Args:
        fuel_type: The type of fuel
            (in [FUEL_TYPES][gemseo_oad_training.models.FUEL_TYPES]).
        n_pax: The number of passengers.
        area: The wing area (in m²)
        ar: The wing aspect ratio.
        tkl: The length of the lh2 tank (in m).
        vi: The volumetric index of lh2 tank.

    Returns:
        The wing span (`span`, in m),
        the fuselage length (`length`, in m) and
        the fuselage tank volume (`tkv`, in m3).
    """
    span = np.sqrt(area * ar)

    if fuel_type == "kerosene":
        length = 12 + n_pax / 6
        tkv = 0.2 * area
    elif fuel_type == "battery":
        length = 12 + n_pax / 6
        tkv = 0.1 * area
    elif fuel_type == "liquid_h2":
        length = 12.0 + n_pax / 6.0 + tkl
        tkv = vi * 36 * tkl
    else:
        _raise_fuel_type_error()

    return span, length, tkv


def target_length(
    fuel_type: str = "liquid_h2", n_pax: float = 150.0, l_target: float = 40.0
) -> float:
    """Compute the hydrogen tank length.

    Args:
        fuel_type: The type of fuel
            (in [FUEL_TYPES][gemseo_oad_training.models.FUEL_TYPES]).
        n_pax: The number of passengers.
        l_target: The targeted fuselage length (in m).

    Returns:
        The length of the lh2 tank (`tkl`, in m).
    """
    if fuel_type == "liquid_h2":
        tkl = l_target - (12.0 + n_pax / 6.0)
    else:
        msg = "target_fuselage_length works only with fuel_type = 'liquid_h2'"
        raise ValueError(msg)

    return tkl


def _cl_max(hld: float) -> float:
    """Computes the maximum Cl.

    Args:
        hld: The high lift device coefficient.

    Returns:
        The maximum Cl.
    """
    return (1 - hld) * 2.0 + hld * 3.0


def aerodynamic(
    area: float = 114.0, ar: float = 9.0, length: float = 37.0, aef: float = 1.0
) -> tuple[float, float, float, float]:
    """Compute the aerodynamic data.

    Args:
        area: The wing area (in m²).
        ar: The wing aspect ratio.
        length: The length of the fuselage (in m).
        aef: The aerodynamic efficiency factor.

    Returns:
        The maximum value of the lift coefficient for take-off (`cl_max_to`),
        the maximum value of the lift coefficient for approach (`cl_max_ld`),
        the drag coefficient independent of lift (`cx0`)
        and the induced drag factor (`ki`).
    """
    cl_max_to = _cl_max(0.3)
    cl_max_ld = _cl_max(0.9)

    cx0 = (2 + (50 + 8.108 * length) / area) * 0.00415 * aef
    ki = 1.1 / (np.pi * ar)

    return cl_max_to, cl_max_ld, cx0, ki


def engine(
    engine_type: str = "turbofan",
    fuel_type: str = "kerosene",
    bpr: float = 9.0,
    slst: float = 114000.0,
    fc_pwd: float = unit.convert_from("kW", 1.0),
    cef: float = 1.0,
) -> tuple[float, float, float, float, float, float]:
    """Compute the engine data.

    Args:
        engine_type: The type of engine
            (in [ENGINE_TYPES][gemseo_oad_training.models.ENGINE_TYPES]).
        fuel_type: The type of fuel
            (in [FUEL_TYPES][gemseo_oad_training.models.FUEL_TYPES]).
        bpr: The engine bypass ratio.
        slst: The maximum sea level static thrust (in N).
        fc_pwd: The fuel cell power density (in W).
        cef: The consumption efficiency factor.

    Returns:
        The specific fuel consumption in cruise conditions (`sfc`, in kg/s/N),
        the specific energy consumption in cruise conditions (`sec`, W/N),
        the maximum thrust in take-off conditions (`fn_ton`, in N),
        the maximum thrust in top of climb conditions (`fn_mcl`, in N),
        the total engine mass (`m_engine`, in kg) and
        the total fuel cell mass (`m_fuel_cell`, in kg).
    """
    pwd = {
        # source Magnix
        "emotor": unit.convert_from("kW", 4.5),
        # source Magnix
        "power_elec": unit.convert_from("kW", 10),
        # source HorizonFuelCell : 770 W/kg
        "fuel_cell": unit.convert_from("kW", 1),
        "fan": unit.convert_from("kW", 15),
    }

    eta = {"emotor": 0.95, "power_elec": 0.98, "fuel_cell": 0.55, "fan": 0.80}

    if engine_type == "electrofan" and fuel_type == "kerosene":
        msg = (
            "fuel_type = 'kerosene' cannot be combined with engine_type = 'electrofan'"
        )
        raise ValueError(msg)
    if engine_type == "turbofan" and fuel_type == "battery":
        msg = "fuel_type = 'battery' cannot be combined with engine_type = 'turbofan'"
        raise ValueError(msg)

    n_engine = 2  # Number of engine
    cruise_mach = 0.78  # Design mach number
    tas = cruise_mach * 297  # (297 m/s is sound speed at 35000ft, ISA)

    max_power = 0.8 * slst * 85  # One engine, sea level, isa, mach 0.25

    # Specific fuel consumption
    if fuel_type == "kerosene":
        sfc = (0.4 + 1 / bpr**0.895) / 36000
        sec = sfc * 43.0e6
    elif fuel_type == "liquid_h2":
        if engine_type == "turbofan":
            sfc = (43 / 121) * (0.4 + 1 / bpr**0.895) / 36000
            sec = sfc * 121.0e6
        elif engine_type == "electrofan":
            sfc = tas / (
                eta["fan"]
                * eta["emotor"]
                * eta["power_elec"]
                * eta["fuel_cell"]
                * 121.0e6
            )
            sec = sfc * 121.0e6
        else:
            msg = "engine_type must be 'turbofan' or 'electrofan'"
            raise ValueError(msg)
    elif fuel_type == "battery":
        sfc = 0
        sec = tas / (eta["fan"] * eta["emotor"] * eta["power_elec"])
    else:
        _raise_fuel_type_error()

    sfc *= cef
    sec *= cef

    fn_ton = 0.80 * slst  # MTO rating, SL, ISA, mach 0.25
    fn_mcl = 0.19 * slst  # MCL rating, 35000 ft, ISA, cruise mach

    if engine_type == "turbofan":
        m_engine = (0.0272 * slst + 100 * (bpr - 5)) * n_engine
    elif engine_type == "electrofan":
        m_engine = (
            (1 / pwd["emotor"] + 1 / pwd["power_elec"] + 1 / pwd["fan"])
            * max_power
            * n_engine
        )
    else:
        msg = "engine_type must be 'turbofan' or 'electrofan'"
        raise ValueError(msg)

    if fuel_type == "liquid_h2" and engine_type == "electrofan":
        m_fuel_cell = n_engine * max_power / fc_pwd
    else:
        m_fuel_cell = 0.0

    return sfc, sec, fn_ton, fn_mcl, m_engine, m_fuel_cell


def fuel_tank(
    fuel_type: str = "kerosene",
    gi: float = 0.4,
    tkv: float = 20.0,
) -> tuple[float, float]:
    """Compute the tank data.

    Args:
        fuel_type: The type of fuel
            (in [FUEL_TYPES][gemseo_oad_training.models.FUEL_TYPES]).
        gi: The tank gravimetric index (in m3), expressed as m_lh2 / (m_tank + m_lh2).
        tkv: The fuel tank volume (in m3).

    Returns:
        The specific fuel consumption in cruise conditions (`m_tank`, in kg/s/N)
        and the maximum fuel mass (`mfm`, in kg).
    """
    if fuel_type == "kerosene":
        mfm = 803.0 * tkv  # Max fuel mass of kerosene
        m_tank = 0.0  # The fuel is in the wing box
    elif fuel_type == "liquid_h2":
        mfm = 71.0 * tkv  # Max fuel mass of liquid hydrogen
        m_tank = mfm * ((1 - gi) / gi)  # The fuel is in the rear fuselage
    elif fuel_type == "battery":
        mfm = 0.0
        m_tank = 0.0
    else:
        _raise_fuel_type_error()
    return m_tank, mfm


def battery(
    fuel_type: str = "battery",
    total_enrg: float = unit.convert_from("MWh", 6),
    bed: float = unit.convert_from("Wh", 400),
    tkv: float = 20.0,
) -> tuple[float, float]:
    """Compute the battery data.

    Args:
        fuel_type: The type of fuel
            (in [FUEL_TYPES][gemseo_oad_training.models.FUEL_TYPES]).
        total_enrg: The total energy to store in the battery (in J).
        bed: The battery energy density (in J/kg).
        tkv: The fuel tank volume (in m3).

    Returns:
        The required battery mass (`m_battery`, in kg)
        and the maximum battery mass (`mbm`, in kg).
    """
    if fuel_type == "battery":
        mbm = 2800.0 * tkv  # Max battery mass
        m_battery = total_enrg / bed  # Battery is located in the wing box
    elif fuel_type in ["kerosene", "liquid_h2"]:
        mbm = 0.0
        m_battery = 0.0
    else:
        _raise_fuel_type_error()
    return m_battery, mbm


def mass(
    fuel_type: str = "kerosene",
    mtom: float = 77000.0,
    mzfm: float = 70000.0,
    m_engine: float = 8000.0,
    m_fuel_cell: float = 10000.0,
    m_tank: float = 10000.0,
    m_battery: float = 0.0,
    n_pax: float = 150,
    area: float = 114.0,
    span: float = 32.0,
    ar: float = 9.0,
    tkl: float = 2.75,
    sef: float = 1.0,
) -> tuple[float, float, float]:
    """Compute the operational empty mass.

    Args:
        fuel_type: The type of fuel
            (in [FUEL_TYPES][gemseo_oad_training.models.FUEL_TYPES]).
        mtom: The maximum take-off mass (in kg).
        mzfm: The maximum zero fuel mass (in kg).
        m_engine: The total engine mass (in kg).
        m_fuel_cell: The total fuel cell mass (in kg).
        m_tank: The tank mass (in kg).
        m_battery: The required battery mass (in kg).
        n_pax: The number of passengers.
        area: The wing area (in m²).
        span: The wing span (in m).
        ar: The wing aspect ratio.
        tkl: The length of the lh2 tank (in m).
        sef: The structural efficiency factor.

    Returns:
        The maximum payload (`payload_max`, in kg),
        the nominal payload (`payload`, in kg) and
        the operational empty mass (`oem`, in kg).
    """
    payload = 100 * n_pax  # 100 : Nominal passenger + baggage allowance
    payload_max = 120 * n_pax  # 120 : Maximum passenger + baggage allowance

    a = 32 * area**1.1
    b = 4.0 * span**2 * np.sqrt(mtom) * np.sqrt(mzfm)
    c = 1.1e-6 * (1 + 2 * ar) / (1 + ar)
    d = 0.1076 * (area / span)
    wm = a + (b * c) / d  # Wing mass

    # Fuselage mass variation
    if fuel_type in ["kerosene", "battery"]:
        dfm = 48 * (n_pax - 150)
    elif fuel_type == "liquid_h2":
        dfm = 48 * (n_pax - 150) + 280 * ((n_pax - 150) / 6 + tkl)
    else:
        _raise_fuel_type_error()

    oem = (
        (19000.0 + 0.0893 * mtom + wm + dfm) * sef
        + m_engine
        + m_fuel_cell
        + m_tank
        + m_battery
    )

    return payload, payload_max, oem


def total_mass(
    fuel_type: str = "kerosene",
    oem: float = 42000.0,
    payload: float = 15000.0,
    payload_max: float = 18000.0,
    mfm: float = 20000.0,
    mbm: float = 0.0,
    total_fuel: float = 15000.0,
    total_enrg: float = unit.convert_from("MWh", 6),
    bed: float = unit.convert_from("Wh", 400.0),
    use_maximum_fuel: bool = False,
) -> tuple[float, float, float, float]:
    """Compute the total mass.

    Args:
        fuel_type: The type of fuel
            (in [FUEL_TYPES][gemseo_oad_training.models.FUEL_TYPES]).
        oem: The operational empty mass (in kg).
        payload: The nominal payload (in kg).
        payload_max: The maximum payload (in kg).
        mfm: The maximum fuel mass (in kg).
        mbm: The maximum battery mass (in kg).
        total_fuel: The total mission fuel, including reserve (in kg).
        total_enrg: The total mission energy, including reserve (in J).
        bed: The battery energy density (in J/kg).
        use_maximum_fuel: Whether to use the whole fuel to get the design range.

    Returns:
        The maximum take-off mass (`mtom`, in kg)
        the maximum zero fuel mass (`mzfm`, in kg)
        the maximum landing mass (`mlm`, in kg) and
        the fuel margin (`fm`, in nd).
    """
    if use_maximum_fuel:
        total_fuel = mfm
    mzfm = oem + payload_max
    if fuel_type in ["kerosene", "liquid_h2"]:
        mtom = oem + payload + total_fuel
        mlm = 1.07 * mzfm
        fm = (mfm - total_fuel) / total_fuel
    elif fuel_type == "battery":
        mtom = oem + payload_max
        mlm = mtom
        fm = (mbm * bed - total_enrg) / total_enrg
    else:
        _raise_fuel_type_error()
    return mtom, mzfm, mlm, fm


def mission(
    fuel_type: str = "kerosene",
    mtom: float = 77000.0,
    design_range: float = 5500.0e3,
    sfc: float = unit.convert_from("kg/h/daN", 0.54),
    sec: float = unit.convert_from("kW/daN", 3.0),
    area: float = 114.0,
    cx0: float = 0.0220,
    ki: float = 0.039,
    ode_type: str = "breguet",
) -> tuple[float, float]:
    """Compute the mission fuel.

    Based on the Breguet range equation.

    Args:
        fuel_type: The type of fuel
            (in [FUEL_TYPES][gemseo_oad_training.models.FUEL_TYPES]).
        mtom: The maximum take-off mass (in kg).
        design_range: The design range (in m).
        sfc: The specific fuel consumption in cruise conditions (in kg/s/N).
        sec: The specific energy consumption in cruise conditions (in W/N).
        area: The wing area (in m²).
        cx0: The drag coefficient independent of lift.
        ki: The induced drag factor.
        ode_type: The method to compute the mission range
            (in [ODE_TYPES][gemseo_oad_training.models.ODE_TYPES]).

    Returns:
        The total mission fuel (`total_fuel`, in kg, including reserve)
        and the total mission energy (`total_enrg`, in kg, including reserve).
    """
    g = 9.81  # Gravity acceleration
    res_factor = 0.05  # Fuel reserve factor (5%)
    cruise_mach = 0.78  # Design mach number
    pamb = 23840.0  # Pressure at 35000 ft
    tas = cruise_mach * 297  # (297 m/s is sound speed at 35000ft, ISA)

    if ode_type == "breguet":
        # Computing total_fuel using Breguet equation
        lod = 0.5 / np.sqrt(cx0 * ki)
        if fuel_type in ["kerosene", "liquid_h2"]:
            total_fuel = (
                mtom
                * (1 - np.exp(-(sfc * g * design_range) / (tas * lod)))
                * (1 + res_factor)
            )
            total_enrg = 0.0

        elif fuel_type == "battery":
            total_fuel = 0.0
            total_enrg = (
                mtom * ((sec * g * design_range) / (tas * lod)) * (1 + res_factor)
            )
        else:
            _raise_fuel_type_error()

    elif ode_type == "ivp":  # Initial Value Problem
        if fuel_type in ["kerosene", "liquid_h2"]:
            # Compute total_fuel using ODE solver
            fac = 0.7 * pamb * cruise_mach**2 * area / g

            state_dot = lambda t, state: [  # noqa:E731
                tas,
                -g * sfc * (cx0 * fac + ki * state[1] ** 2 / fac),
            ]  # noqa:E731

            stop_cnd = lambda t, state: design_range - state[0]  # noqa:E731

            t0 = 0.0
            t1 = 10 * 3600.0
            state0 = [0.0, mtom]  # [x_position, starting_mass]

            res = solve_ivp(
                state_dot,
                [t0, t1],
                state0,
                args=(),
                t_eval=None,
                atol=1e-9,
                rtol=1e-9,
                method="RK45",
                events=stop_cnd,
            )

            if len(res.t_events[0]) > 0:  # Check if stop condition has been reached
                final_mass = res.y_events[0][0][1]
            else:
                msg = "Cannot reach cruise mission end within given time : "
                raise ValueError(msg, t1 / 3600, " h")

            total_fuel = (mtom - final_mass) * (
                1 + res_factor
            )  # Total fuel including reserve
            total_enrg = 0.0

        elif fuel_type == "battery":
            # Comput total_enrg using ODE solver
            msg = "Case ode_type = 'ivp' and fuel_type = 'battery' must be implemented"
            raise ValueError(msg)

        else:
            _raise_fuel_type_error()

    else:
        msg = "ode_type must be 'breguet' or 'ivp'"
        raise ValueError(msg)

    return total_fuel, total_enrg


def mission_2(
    fuel_type: str = "kerosene",
    mtom: float = 77000.0,
    mfm: float = 15000.0,
    total_enrg: float = unit.convert_from("MWh", 6.0),
    sfc: float = unit.convert_from("kg/h/daN", 0.54),
    sec: float = unit.convert_from("kW/daN", 3.0),
    area: float = 114.0,
    cx0: float = 0.0220,
    ki: float = 0.039,
    ode_type: str = "breguet",
) -> float:
    """Compute the mission fuel.

    Based on the Breguet range equation.

    Args:
        fuel_type: The type of fuel
            (in [FUEL_TYPES][gemseo_oad_training.models.FUEL_TYPES]).
        mtom: The maximum take-off mass (in kg).
        mfm: kg, Maximum  (including reserve)
        total_enrg: The total mission energy, including reserve (in J).
        sfc: The specific fuel consumption in cruise conditions (in kg/s/N).
        sec: The specific energy consumption in cruise conditions (in W/N).
        area: The wing area (in m²).
        cx0: The drag coefficient independent of lift.
        ki: The induced drag factor.
        ode_type: The method to compute the mission range
            (in [ODE_TYPES][gemseo_oad_training.models.ODE_TYPES]).

    Returns:
        The possible range (`mission_range`, in m).
    """
    g = 9.81  # Gravity acceleration
    res_factor = 0.05  # Fuel reserve factor (5%)
    cruise_mach = 0.78  # Design mach number
    pamb = 23840.0  # Pressure at 35000 ft
    tas = cruise_mach * 297  # (297 m/s is sound speed at 35000ft, ISA)

    if ode_type == "breguet":
        # Computing total_fuel using Breguet equation
        lod = 0.5 / np.sqrt(cx0 * ki)
        if fuel_type in ["kerosene", "liquid_h2"]:
            mission_fuel = mfm / (1 + res_factor)
            mission_range = ((tas * lod) / (sfc * g)) * np.log(
                mtom / (mtom - mission_fuel)
            )
        elif fuel_type == "battery":
            mission_enrg = total_enrg / (1 + res_factor)
            mission_range = ((tas * lod) / (sec * g)) * (mission_enrg / mtom)
        else:
            _raise_fuel_type_error()

    elif ode_type == "ivp":  # Initial Value Problem
        if fuel_type in ["kerosene", "liquid_h2"]:
            # Comput total_fuel using ODE solver
            mission_fuel = mfm / (1 + res_factor)
            fac = 0.7 * pamb * cruise_mach**2 * area / g

            # state_dot = lambda t, state:
            # [tas, -g * sfc * (cx0 * fac + ki * state[1] ** 2 / fac)]
            state_dot = lambda t, state: [  # noqa:E731
                tas,  # noqa:E731
                -g * sfc * (cx0 * fac + ki * state[1] ** 2 / fac),  # noqa:E731
            ]  # noqa:E731

            stop_cnd = lambda t, state: mission_fuel - (mtom - state[1])  # noqa:E731

            t0 = 0.0
            t1 = 10 * 3600.0
            state0 = [0.0, mtom]  # [x_position, starting_mass]

            res = solve_ivp(
                state_dot,
                [t0, t1],
                state0,
                args=(),
                t_eval=None,
                atol=1e-9,
                rtol=1e-9,
                method="RK45",
                events=stop_cnd,
            )

            if len(res.t_events[0]) > 0:  # Check if stop condition has been reached
                mission_range = res.y_events[0][0][0]
            else:
                msg = "Cannot reach cruise mission end within given time : "
                raise RuntimeError(msg, t1 / 3600, " h")

        elif fuel_type == "battery":
            # Comput total_enrg using ODE solver
            mission_enrg = total_enrg / (1 + res_factor)
            fac = 0.7 * pamb * cruise_mach**2 * area / g
            power = g * sec * (cx0 * fac + ki * mtom**2 / fac)

            state_dot = lambda t, state: [tas, -power]  # noqa:E731

            stop_cnd = lambda t, state: state[1]  # noqa:E731

            t0 = 0.0
            t1 = 10 * 3600.0
            state0 = [0.0, mission_enrg]  # [x_position, initial_energy]

            msg = "Case ode_type = 'ivp' and fuel_type = 'battery' must be implemented"
            raise ValueError(msg)

            # Put here the code to compute mission_range : the final value of state[0]

            mission_range = np.nan

        else:
            _raise_fuel_type_error()

    else:
        msg = "ode_type must be 'breguet' or 'ivp'"
        raise ValueError(msg)

    return mission_range


def take_off(
    mtom: float = 77000.0,
    fn_ton: float = 100.0e3,
    area: float = 114.0,
    cl_max_to: float = 2.3,
) -> float:
    """Compute the take-off field length.

    Based on the Magic Line method.

    Args:
        mtom: The maximum take-off mass (in kg).
        fn_ton: The maximum thrust in take-off conditions (in N).
        area: The wing area (in m²).
        cl_max_to: The maximum value of the lift coefficient for take-off.

    Returns:
        The take-off field length (`tofl`, in m).
    """
    n_engine = 2  # Number of engine
    rho = 1.225  # Air density at seal level
    sig = rho / 1.225  # Sigma
    kvs1g_to = 1.13  # Speed margin factor for take-off
    cl_to = cl_max_to / kvs1g_to**2
    kml = mtom**2 / (cl_to * n_engine * fn_ton * area * sig**0.8)
    tofl = 14.23 * kml
    tofl += 97.58
    return tofl


def approach(
    mlm: float = 64000.0, area: float = 114.0, cl_max_ld: float = 2.9
) -> float:
    """Compute the Approach speed.

    Based on the minimum VREF evaluated as 1.23 Vs1g.

    Args:
        mlm: The maximum landing mass (in kg).
        area: The wing area (in m²).
        cl_max_ld: The maximum value of the lift coefficient for approach.

    Returns:
        The approach speed (`vapp`, in m/s).
    """
    g = 9.81  # Gravity acceleration
    rho = 1.225  # Air density at seal level
    kvs1g_ld = 1.23  # Speed margin factor for approach

    cl_ld = cl_max_ld / kvs1g_ld**2
    vapp = np.sqrt((mlm * g) / (0.5 * rho * area * cl_ld))
    vapp *= 1.0  # To avoid Ruff auto format break autopydiscipline
    return vapp


def climb(
    mtom: float = 77000.0,
    fn_mcl: float = 25000.0,
    cx0: float = 0.0220,
    ki: float = 0.039,
) -> float:
    """Compute the vertical speed evaluation at top of climb.

    Supposing constant Mach trajectory at 78% cruise Mach.

    Args:
        mtom: The maximum take-off mass (in kg).
        fn_mcl: The maximum thrust in top of climb conditions (in N).
        cx0: The drag coefficient independent of lift.
        ki: The induced drag factor.

    Returns:
        The vertical speed (`vz`, in m/s).
    """
    g = 9.81  # Gravity acceleration
    n_engine = 2  # Number of engines
    cruise_mach = 0.78  # Design mach number
    tas = cruise_mach * 297  # (m/s, mach 0.78, 35000ft, ISA)
    mass = 0.97 * mtom  # Top of climb mass
    fac = 1 + 20.49 * cruise_mach**2 * (-0.0065)  # Constant Mach climb
    lod = 0.5 / np.sqrt(cx0 * ki)
    vz = (n_engine * fn_mcl / (mass * g) - 1 / lod) / fac
    vz *= tas
    return vz


def operating_cost(
    n_pax: float = 150.0,
    payload: float = 15000.0,
    oem: float = 42000.0,
    mtom: float = 77000.0,
    m_engine: float = 8000.0,
    m_fuel_cell: float = 10000.0,
    m_tank: float = 10000.0,
    m_battery: float = 0.0,
    slst: float = 114000.0,
    sfc: float = unit.convert_from("kg/h/daN", 0.54),
    sec: float = unit.convert_from("kW/daN", 3.0),
    cx0: float = 0.0220,
    ki: float = 0.039,
    bed: float = unit.convert_from("Wh", 400),
    fuel_type: str = "kerosene",
    engine_type: str = "turbofan",
) -> tuple[float, float]:
    """Compute the operating costs.

    Based on the Thorbeck method.

    Args:
        n_pax: The number of passengers.
        payload: The nominal payload (in kg).
        oem: The operating empty mass (in kg).
        mtom: The maximum take-off mass (in kg).
        m_engine: The total engine mass (in kg).
        m_fuel_cell: The fuel cell pack mass (in kg).
        m_tank: The tank mass (in kg).
        m_battery: The battery mass (in kg).
        slst: The maximum sea level static thrust (in N).
        sfc: The specific fuel consumption in cruise conditions (in kg/s/N).
        sec: The specific energy consumption in cruise conditions (in W/N).
        cx0: The drag coefficient independent of lift.
        ki: The induced drag factor.
        bed: The battery energy density (in J/kg).
        fuel_type: The type of fuel
            (in [FUEL_TYPES][gemseo_oad_training.models.FUEL_TYPES]).
        engine_type: The type of engine
            (in [ENGINE_TYPES][gemseo_oad_training.models.ENGINE_TYPES]).

    Returns:
        The cash operating cost per flight (`coc`, in $/trip) and
        the direct operating cost per flight (`doc`, in $/trip).
    """
    fuel_cell_power_density = unit.convert_from("kW", 1)  # 1 kW/kg

    energy_price = {
        "kerosene": 50.0 / unit.convert_from("MWh", 1),  # $/MWh
        "efuel": 125.0 / unit.convert_from("MWh", 1),  # $/MWh
        "liquid_h2": 140.0 / unit.convert_from("MWh", 1),  # $/MWh (2035)
        "battery": 110.0 / unit.convert_from("MWh", 1),
    }  # $/MWh, 0.11 euros/kWh

    euro_dollar = 1.2

    cd = {
        "airframe_mass_price": 1150 * euro_dollar,
        "thermal_engine_mass_price": 2500 * euro_dollar,
        "depreciation_period": 14,  # Years
        "interest_rate": 0.05,
        "residual_value_factor": 0.1,
        "insurance_rate": 0.005,
        "flight_attd_salary": 60000 * euro_dollar,  # $/year/flight_attendent
        "flight_crew_salary": 300000 * euro_dollar,  # $/year/2pilots
        "crew_complement": 5,  # Number of crew per airplane
        "handling_fees": 0.1 * euro_dollar,  # Cost per kg of payload
        "landing_fees": 0.01 * euro_dollar,  # Cost per kg of MTOW
        "labor_cost": 50 * euro_dollar,  # Cost per hour
        "burden_factor": 2,
    }

    td = {  # ref M.Marksel et A.Prapotnik Brdnik, « Comparative Analysis  of
        # Direct Operating  Costs: Conventional vs.Hydrogen
        # Fuel  Cell 19 - Seat Aircraft », Sustainability
        "fuel_cell_maintenance_factor": 1.277e-4,
        # ref K.O.Ploetner, « Operating Cost Estimation for Electric -
        # Powered Transport Aircraft »,
        "emotor_maintenance_factor": 0.75,
        "emotor_power_price": 94
        * euro_dollar
        / unit.convert_from("kW", 1),  # 94 euro/kW
        "fuel_cell_power_price": 40
        * euro_dollar
        / unit.convert_from("kW", 1),  # 40 euro/kW
        # ref BER, “Fast-Forwarding to a Future of On-Demand
        # Urban Air Transportation,” 2016.
        # ref chäfer, A. W., Barrett, S. R. H., and Doyme1, K.,
        # “Technological, economic and environmental prospects of all-electric
        # aircraft,” Nature Energy, 2018.
        "battery_capacity_price": 300 / unit.convert_from("Wh", 1),  # 300 euro/Wh
        # ref A First-Order Analysis of Direct Operating Costs of
        # Battery Electric Aircraft of Zayat Kinan Al
        # ref [1] « The Commonwealth Scientific and Industrial Research Organisation »,
        # Current, propose 4000 for battery lifetime cycle
        "battery_lifetime_cycle": 5000,  # cycles
        # ref https://ec.europa.eu/info/funding-tenders/opportunities/portal/screen/
        # opportunities/topic-details/horizon-jti-cleanh2-2023-07-01
        "lh2_tank_mass_price": 245 * euro_dollar,
    }  # euro/kg

    traffic_zone_factor = {"domestic_europe": 1.0, "west_bound": 0.7, "east_bound": 0.6}

    n_engine = 2
    max_power = 0.8 * slst * 85  # One engine, sea level, isa, mach 0.25

    # Cost mission
    traffic_zone = "west_bound"
    cost_range = unit.convert_from("km", 3000)
    flight_attd_count = np.ceil(n_pax / 50)

    # Computing cost mission energy consumption using Breguet equation
    g = 9.81  # Gravity acceleration
    cruise_mach = 0.78  # Design mach number
    tas = cruise_mach * 297  # (297 m/s is sound speed at 35000ft, ISA)
    mission_time = cost_range / tas

    lod = 0.5 / np.sqrt(cx0 * ki)
    if fuel_type == "battery":
        fac = (sec * g * cost_range) / (tas * lod)
        mission_enrg = (oem + payload) * (fac / (1 - fac))
    elif fuel_type in ["kerosene", "liquid_h2"]:
        fac = 1 - np.exp(-(sfc * g * cost_range) / (tas * lod))
        mission_fuel = (oem + payload) * (fac / (1 - fac))
        mission_enrg = mission_fuel * 43.0e6
    else:
        _raise_fuel_type_error()

    # Source : A simplified DOC method, TU Berlin by Thorbeck

    flight_cycle_count = 6011.2 / (mission_time / 3600 + 1.83)

    airframe_price = cd["airframe_mass_price"] * (oem - m_engine)

    battery_yearly_capital_cost = 0
    fuel_cell_price = 0
    tank_price = 0

    if engine_type == "electrofan":
        engine_price = td["emotor_power_price"] * max_power * n_engine
        if fuel_type == "liquid_h2":
            fuel_cell_price = (
                td["fuel_cell_power_price"] * fuel_cell_power_density * m_fuel_cell
            )
    else:
        engine_price = cd["thermal_engine_mass_price"] * m_engine

    if fuel_type == "liquid_h2":
        tank_price = m_tank * td["lh2_tank_mass_price"]
    elif fuel_type == "battery":
        battery_price = m_battery * bed * td["battery_capacity_price"]
        battery_depreciation_period = td["battery_lifetime_cycle"] / flight_cycle_count
        fac = (1 / (1 + cd["interest_rate"])) ** battery_depreciation_period
        battery_annuity_factor = (
            cd["interest_rate"] * (1 - cd["residual_value_factor"] * fac) / (1 - fac)
        )
        battery_yearly_capital_cost = battery_price * (
            battery_annuity_factor + cd["insurance_rate"]
        )

    fac = (1 / (1 + cd["interest_rate"])) ** cd["depreciation_period"]
    annuity_factor = (
        cd["interest_rate"] * (1 - cd["residual_value_factor"] * fac) / (1 - fac)
    )
    yearly_capital_cost = (
        airframe_price + engine_price + fuel_cell_price + tank_price
    ) * (annuity_factor + cd["insurance_rate"]) + battery_yearly_capital_cost

    yearly_crew_cost = cd["crew_complement"] * (
        cd["flight_attd_salary"] * flight_attd_count + cd["flight_crew_salary"]
    )

    block_time_hour = mission_time / 3600
    airframe_material_cost = (oem / 1000) * (0.21 * block_time_hour + 13.7) + 57.5
    airframe_labor_cost = (
        cd["labor_cost"]
        * (1 + cd["burden_factor"])
        * (
            (0.655 + 0.01 * (oem / 1000)) * block_time_hour
            + 0.254
            + 0.01 * (oem / 1000)
        )
    )
    engine_maintenance_cost = n_engine * (
        1.5 * unit.convert_to("kgf", slst) / 1000 + 30.5 * block_time_hour + 10.6
    )

    if engine_type == "electrofan":
        engine_maintenance_cost = (
            engine_maintenance_cost * td["emotor_maintenance_factor"]
        )

    flight_maintenance_cost = (
        airframe_material_cost + airframe_labor_cost + engine_maintenance_cost
    )

    yearly_flight_cost = (
        mission_enrg * energy_price[fuel_type]
        + payload * cd["handling_fees"]
        + mtom * cd["landing_fees"]
        + traffic_zone_factor[traffic_zone]
        * (cost_range / 1000)
        * np.sqrt(mtom / 50000)
        + flight_maintenance_cost
    ) * flight_cycle_count

    yearly_cash_operating_cost = yearly_crew_cost + yearly_flight_cost
    yearly_direct_operating_cost = yearly_cash_operating_cost + yearly_capital_cost

    coc = yearly_cash_operating_cost / flight_cycle_count
    doc = yearly_direct_operating_cost / flight_cycle_count

    return coc, doc
