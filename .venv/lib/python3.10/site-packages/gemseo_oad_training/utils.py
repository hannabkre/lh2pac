# Copyright 2024 ENAC
# Copyright 2021 IRT Saint Exupéry, https://www.irt-saintexupery.com
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License version 3 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program; if not, write to the Free Software Foundation,
# Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
# :author: Conceptual Airplane Design & Operations (CADO team, ENAC)
#          Thierry DRUOT
# Code improvements:
#          François Gallard
#          Matthias De Lozzo
#          IRT Saint Exupéry
"""Utils."""

from __future__ import annotations

from typing import TYPE_CHECKING

import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np
from gemseo.utils.matplotlib_figure import save_show_figure
from mpl_toolkits.axes_grid1.inset_locator import inset_axes
from scipy import interpolate

from gemseo_oad_training import unit

if TYPE_CHECKING:
    from pathlib import Path


def pretty_print(fmt, d):
    """Print a numerical value on a string with defined format.

    Args:
        fmt: format, ex: "%8.2f"
        d: dictionary [value, unit_name], unit_name is from unit.py

    Returns:
        The printed value as a string

    """
    if d[1] == "string":
        return d[0]
    w = str(unit.convert_to(d[1], d[0]))
    s = eval("'" + fmt + "'" + "%" + w)
    return s + " " + d[1]


def draw_design_space(
    scan,
    var,
    field,
    other,
    const,
    color,
    limit,
    bound,
    optim_points=None,
    add_to_title="",
):
    """Draw the design space.

    Plots around the center of the scan on var[0] and var[1].
    The user can click on the graph and probe the corresponding values
    Variable names must be consistent with file content.

    Args:
        scan: input data as a dictionary {"name":[list of variable names],
                                          "unit":[list of unit names],
                                          "data":[list of list of values]}
        var: the list of variable names (only 2 names), ex: ["slst", "area"]
        field: the name of the criterion
        other: the list of other variable names to display in the window
        const: the list of constrained variable names to display in the window
        color: the list of the colors to associate with the constraints
        limit: the list of limit values for constraints in standard units
        bound: the list of limit types as upper or lower bounds
        optim_points: the list of successive tries to reach the solution

    Returns:
        The graph window

    """
    name = scan["name"]  # Extract variable names
    uni_ = scan["unit"]  # Extract unit names
    data = scan["data"]  # Extract data values

    dat, uni = {}, {}
    for j in range(len(name)):
        dat[name[j]] = np.array([v[j] for v in data])  # Transpose data
        uni[name[j]] = uni_[j]

    absc = list(set(dat[var[0]]))
    absc.sort()
    nx = len(absc)

    ordinate = list(set(dat[var[1]]))
    ordinate.sort()
    ny = len(ordinate)

    ctr_bnd = [unit.convert_to(uni[const[k]], v) for k, v in enumerate(limit)]

    res = [np.mean(absc), np.mean(ordinate)]

    mpl.rcParams["hatch.linewidth"] = 0.3

    fig = plt.figure(figsize=(7, 7))
    fig.canvas.manager.set_window_title(
        "GEMSEO pico airplane design test case : " + "Design space exploration"
    )
    cm = 1 / 2.54
    fig.set_size_inches(18 * cm, 18 * cm)
    # set axes size depending on the number of rows in the tables
    n1 = (
        len(list(var)) + 1 + len(list(other))
    )  # number of table rows (variables+field+ other variables)
    n2 = len(list(const))
    n = max(n1, n2)
    # print("n=",n,n1,n2)
    # print(var,field,other)
    ratio = min(1, n / 16)  # 8 lines gives ratio=1
    gs = mpl.gridspec.GridSpec(2, 2, height_ratios=[1, ratio])

    f = {}
    typ = "cubic"

    axe = plt.subplot(gs[0, :])
    x, y = np.meshgrid(absc, ordinate)
    z = dat[field].reshape(ny, nx)
    f[field] = interpolate.interp2d(x, y, z, kind=typ)
    ctf = axe.contourf(x, y, z, cmap=mpl.cm.Greens, levels=10)
    axins = inset_axes(
        axe,
        width="5%",  # width = 5% of parent_bbox width
        height="60%",  # height : 50%
        loc="upper left",
        bbox_to_anchor=(1.03, 0.0, 1, 1),
        bbox_transform=axe.transAxes,
        borderpad=0,
    )
    plt.colorbar(ctf, cax=axins)
    axe.set_title(add_to_title + " - Criterion : " + field + " (" + uni[field] + ")")
    axe.set_xlabel(var[0] + " (" + uni[var[0]] + ")")
    axe.set_ylabel(var[1] + " (" + uni[var[1]] + ")")

    axe.plot(res[0], res[1], "ok", ms="10", mfc="none")  # Draw solution point
    (marker,) = axe.plot(res[0], res[1], "+k", ms="10", mfc="none")  # Draw plot marker

    # Build interpolator for other data
    for j in range(0, len(other), 1):
        z = dat[other[j]].reshape(ny, nx)
        f[other[j]] = interpolate.interp2d(x, y, z, kind=typ)

    bnd = [{"ub": 1.0e10, "lb": -1.0e10}.get(s) for s in bound]

    ctr = []
    hdl = []
    for j in range(0, len(const), 1):
        z = dat[const[j]].reshape(ny, nx)
        f[const[j]] = interpolate.interp2d(x, y, z, kind=typ)
        ctr.append(axe.contour(x, y, z, levels=[ctr_bnd[j]], colors=color[j]))
        levels = [ctr_bnd[j], bnd[j]]
        levels.sort()
        axe.contourf(x, y, z, levels=levels, alpha=0.0, hatches=["/"])
        h, _ = ctr[j].legend_elements()
        hdl.append(h[0])

    axe.legend(hdl, const, loc="lower left", bbox_to_anchor=(1.02, 0.0))

    # Add optim points if specified -------------------------------------
    if optim_points is not None:
        x, y = zip(*optim_points)
        x = np.array(x)  # /10 # /10 to rescale units ...
        # WARNING not very robust !!
        x = unit.convert_to(uni[var[0]], x)
        y = np.array(y)
        y = unit.convert_to(uni[var[1]], y)
        axe.scatter(x, y)
        axe.quiver(
            x[:-1],
            y[:-1],
            x[1:] - x[:-1],
            y[1:] - y[:-1],
            scale_units="xy",
            angles="xy",
            scale=1,
            color="k",
        )

    # Set introspection
    # Discipline-----------------------------------
    axe = plt.subplot(gs[1, 0])
    axe.axis("off")
    val1 = [
        [f"{70000.0:6.2f}", uni[field]],
        [f"{12000.0:6.2f}", uni[var[0]]],
        [f"{135.4:6.2f}", uni[var[1]]],
    ]
    rowlabel = [field, var[0], var[1]]
    for j in range(len(other)):
        val1.append([f"{70000.0:6.0f}", uni[other[j]]])
        rowlabel.append(other[j])

    the_table = axe.table(
        cellText=val1,
        rowLabels=rowlabel,
        rowLoc="right",
        cellLoc="left",
        colWidths=[0.3, 0.3],
        bbox=[0.1, 0.0, 1.0, 1.0],
        edges="closed",
    )
    the_table.auto_set_font_size(False)
    the_table.set_fontsize(10)

    for cell in the_table._cells.values():
        cell.set_edgecolor("silver")

    cst_uni = [uni[c] for c in const]

    val2 = np.random.random(len(const)) * 1000.0  # noqa:NPY002
    val2 = [f"{v:8.1f}" for v in val2]
    cst_val = [f"{v:8.1f}" for v in ctr_bnd]
    val2 = list(map(list, zip(*[val2, cst_val, cst_uni])))

    ax3 = plt.subplot(gs[1, 1])
    ax3.axis("off")
    the_table2 = ax3.table(
        cellText=val2,
        rowLabels=const,
        rowLoc="right",
        cellLoc="left",
        bbox=[0.5, 0.0, 1.0, 1.0],
    )
    the_table2.auto_set_font_size(False)
    the_table2.set_fontsize(10)

    for cell in the_table2._cells.values():
        cell.set_edgecolor("silver")

    the_table[0, 0].get_text().set_text(f"{f[field](res[0], res[1]):6.2f}")
    the_table[1, 0].get_text().set_text(f"{res[0]:6.2f}")
    the_table[2, 0].get_text().set_text(f"{res[1]:6.2f}")
    for j in range(len(other)):
        the_table[3 + j, 0].get_text().set_text(f"{f[other[j]](res[0], res[1]):6.1f}")
    for j in range(len(const)):
        the_table2[j, 0].get_text().set_text(f"{f[const[j]](res[0], res[1]):8.1f}")

    def onclick(event):
        try:
            ix, iy = event.xdata, event.ydata
            the_table[0, 0].get_text().set_text(f"{f[field](ix, iy):6.2f}")
            the_table[1, 0].get_text().set_text(f"{ix:6.2f}")
            the_table[2, 0].get_text().set_text(f"{iy:6.2f}")
            for j in range(len(other)):
                the_table[3 + j, 0].get_text().set_text(f"{f[other[j]](ix, iy):6.1f}")
            for j in range(len(const)):
                the_table2[j, 0].get_text().set_text(f"{f[const[j]](ix, iy):8.1f}")
            marker.set_xdata(ix)
            marker.set_ydata(iy)
            plt.draw()
        except TypeError:
            pass

    fig.canvas.mpl_connect("button_press_event", onclick)

    # Pack and draw
    # Discipline-----------------------------------
    plt.tight_layout()
    plt.show()


def plot_opt_history(obj_history, constr_history, add_to_title=""):
    """Plots the optimization history : objective, constraints.

    Args:
        objective: the list of objective function values
        constraints: the list of constraint function values

    Returns:
        the graph window

    """
    cm = 1 / 2.54
    plt.figure(
        figsize=(18 * cm, 22 * cm),
        num="GEMSEO pico airplane design test case : Objective & Constraints history",
    )

    plt.subplot(611)
    plt.title(add_to_title + " - Objective & Constraints history")
    plt.plot(range(len(obj_history)), obj_history, label="obj history")
    plt.grid(True)
    plt.legend()

    plt.subplot(612)
    plt.plot(
        range(len(constr_history)),
        [ci[0] for ci in constr_history],
        label="tofl constr",
    )
    plt.grid(True)
    plt.legend()

    plt.subplot(613)
    plt.plot(
        range(len(constr_history)),
        [ci[1] for ci in constr_history],
        label="vapp constr",
    )
    plt.grid(True)
    plt.legend()

    plt.subplot(614)
    plt.plot(
        range(len(constr_history)), [ci[2] for ci in constr_history], label="vz constr"
    )
    plt.grid(True)
    plt.legend()

    plt.subplot(615)
    plt.plot(
        range(len(constr_history)),
        [ci[3] for ci in constr_history],
        label="span constr",
    )
    plt.xlabel("Number of calls")
    plt.grid(True)
    plt.legend()

    plt.subplot(616)
    plt.plot(
        range(len(constr_history)),
        [ci[4] for ci in constr_history],
        label="length constr",
    )
    plt.xlabel("Number of calls")
    plt.grid(True)
    plt.legend()

    plt.tight_layout()
    plt.show()


def draw_aircraft(
    area: float = 114.0,
    bpr: float = 9.0,
    length: float = 37.0,
    n_pax: int = 150,
    span: float = 32.0,
    slst: float = 114000.0,
    title: str = "",
    file_path: Path | str = "aircraft_3d.png",
    save: bool = False,
    show: bool = False,
) -> None:
    """Draw an aircraft design from the front, top and side.

    Args:
        area: The wing area (in m²)
        bpr: The engine bypass ratio.
        length: The length of the fuselage (in m).
        n_pax: The number of passengers.
        span: The wing span (in m).
        slst: The maximum sea level static thrust (in N).
        title: The title of the figure.
        file_path: The file path to save the figure.
        save: Whether to save the figure.
        show: Whether to display the figure.
    """
    window_title = "Aircraft design visualization"

    # Drawing_ box
    # Discipline----------------------------------------
    fig, axes = plt.subplots(1, 1)
    fig.canvas.manager.set_window_title(window_title)
    if title:
        fig.suptitle(title, fontsize=14)
    axes.set_aspect("equal", "box")
    plt.plot(
        np.array([0, 100, 100, 0, 0]), np.array([0, 0, 100, 100, 0])
    )  # Draw a square box of 100m side

    x_top_view = 50 - 0.5 * length
    y_top_view = 50

    x_side_view = 50 - 0.5 * length
    y_side_view = 82

    x_front_view = 50
    y_front_view = 10

    ref = {
        "xy": [x_top_view, y_top_view],
        "yz": [x_front_view, y_front_view],
        "xz": [x_side_view, y_side_view],
    }

    l0w, l1, l2, l3, l4, _l5, high = 0, 1, 2, 3, 4, 5, 6

    zframe = {
        "xy": {"body": l2, "wing": l1, "htp": l1, "vtp": l3},  # top
        "yz": {"body": l4, "wing": l3, "htp": l1, "vtp": l2},  # front
        "xz": {"body": l2, "wing": l3, "htp": l3, "vtp": l1},
    }  # side

    curve = {
        "nose1": np.array([
            [0.0000, 0.3339, 0.3339, 0.0000, 0.0000],
            [0.0050, 0.3848, 0.3084, 0.0335, -0.0335],
            [0.0150, 0.4253, 0.2881, 0.0652, -0.0652],
            [0.0500, 0.5033, 0.2490, 0.1101, -0.1101],
            [0.1000, 0.5811, 0.2100, 0.1585, -0.1585],
            [0.1800, 0.6808, 0.1600, 0.2215, -0.2215],
            [0.2773, 0.7704, 0.1151, 0.2859, -0.2859],
            [0.4191, 0.8562, 0.0721, 0.3624, -0.3624],
            [0.5610, 0.9198, 0.0402, 0.4211, -0.4211],
            [0.7738, 0.9816, 0.0092, 0.4761, -0.4761],
            [0.9156, 0.9962, 0.0019, 0.4976, -0.4976],
            [1.0000, 1.0000, 0.0000, 0.5000, -0.5000],
        ]),
        "cone1": np.array([
            [0.0000, 1.0000, 0.0000, 0.5000, -0.5000],
            [0.0213, 1.0000, 0.0082, 0.5000, -0.5000],
            [0.0638, 1.0000, 0.0230, 0.4956, -0.4956],
            [0.1064, 1.0000, 0.0393, 0.4875, -0.4875],
            [0.1489, 1.0000, 0.0556, 0.4794, -0.4794],
            [0.1915, 1.0000, 0.0786, 0.4720, -0.4720],
            [0.2766, 1.0000, 0.1334, 0.4566, -0.4566],
            [0.3617, 1.0000, 0.1964, 0.4330, -0.4330],
            [0.4894, 1.0000, 0.3024, 0.3822, -0.3822],
            [0.6170, 1.0000, 0.4159, 0.3240, -0.3240],
            [0.7447, 1.0000, 0.5374, 0.2577, -0.2577],
            [0.8723, 1.0000, 0.6627, 0.1834, -0.1834],
            [0.8936, 0.9963, 0.6901, 0.1679, -0.1679],
            [0.9149, 0.9881, 0.7139, 0.1524, -0.1524],
            [0.9362, 0.9800, 0.7413, 0.1333, -0.1333],
            [0.9574, 0.9652, 0.7687, 0.1097, -0.1097],
            [0.9787, 0.9533, 0.8043, 0.0788, -0.0788],
            [0.9894, 0.9377, 0.8280, 0.0589, -0.0589],
            [1.0000, 0.9103, 0.8784, 0.0162, -0.0162],
        ]),
        "sec1": np.array([
            [0.5000000, 0.0000000, 0.0000000],
            [0.4903926, 0.0975452, -0.0975452],
            [0.4619398, 0.1913417, -0.1913417],
            [0.4157348, 0.2777851, -0.2777851],
            [0.3535534, 0.3535534, -0.3535534],
            [0.2777851, 0.4157348, -0.4157348],
            [0.1913417, 0.4619398, -0.4619398],
            [0.0975452, 0.4903926, -0.4903926],
            [0.0000000, 0.5000000, -0.5000000],
            [-0.0975452, 0.4903926, -0.4903926],
            [-0.1913417, 0.4619398, -0.4619398],
            [-0.2777851, 0.4157348, -0.4157348],
            [-0.3535534, 0.3535534, -0.3535534],
            [-0.4157348, 0.2777851, -0.2777851],
            [-0.4619398, 0.1913417, -0.1913417],
            [-0.4903926, 0.0975452, -0.0975452],
            [-0.5000000, 0.0000000, 0.0000000],
        ]),
    }

    # Compute components
    # Discipline----------------------------------------
    contour = {}

    # Body
    body_length = length
    body_width = 4
    body_height = 4
    nose_cone_length = 2.00 * body_width
    tail_cone_length = 3.45 * body_width

    nose = curve["nose1"]
    cone = curve["cone1"]
    section = curve["sec1"]

    r_nose = (
        nose_cone_length / body_length
    )  # Fuselage length ratio of nose evolutive part
    r_cone = (
        tail_cone_length / body_length
    )  # Fuselage length ratio of tail cone evolutive part

    cyl_yz = np.stack(
        [
            section[0:, 0] * body_width,
            section[0:, 1] * body_height + 0.5 * body_height,
            section[0:, 2] * body_height + 0.5 * body_height,
        ],
        axis=1,
    )

    body_front = np.vstack([
        np.stack([cyl_yz[0:, 0], cyl_yz[0:, 1]], axis=1),
        np.stack([cyl_yz[::-1, 0], cyl_yz[::-1, 2]], axis=1),
    ])

    nose_xz = np.stack(
        [
            nose[0:, 0] * body_length * r_nose,
            nose[0:, 1] * body_height,
            nose[0:, 2] * body_height,
        ],
        axis=1,
    )
    cone_xz = np.stack(
        [
            (1 - r_cone) * body_length + cone[0:, 0] * body_length * r_cone,
            cone[0:, 1] * body_height,
            cone[0:, 2] * body_height,
        ],
        axis=1,
    )
    body_xz = np.vstack([nose_xz, cone_xz])

    body_side = np.vstack([
        np.stack([body_xz[0:-2, 0], body_xz[0:-2, 1]], axis=1),
        np.stack([body_xz[:0:-1, 0], body_xz[:0:-1, 2]], axis=1),
    ])

    nose_xy = np.stack(
        [
            nose[0:, 0] * body_length * r_nose,
            nose[0:, 3] * body_width,
            nose[0:, 4] * body_width,
        ],
        axis=1,
    )
    cone_xy = np.stack(
        [
            (1 - r_cone) * body_length + cone[0:, 0] * body_length * r_cone,
            cone[0:, 3] * body_width,
            cone[0:, 4] * body_width,
        ],
        axis=1,
    )
    body_xy = np.vstack([nose_xy, cone_xy])

    body_top = np.vstack([
        np.stack([body_xy[1:-2, 0], body_xy[1:-2, 1]], axis=1),
        np.stack([body_xy[:0:-1, 0], body_xy[:0:-1, 2]], axis=1),
    ])

    contour["body"] = {"xy": body_top, "yz": body_front, "xz": body_side}

    # Wing
    fuselage_width = 4
    fuselage_cabin_center = 2.0 * fuselage_width + 0.45 * n_pax / 6

    landing_gears_leg_length = 3.7

    sweep25 = unit.convert_from("deg", 25)
    dihedral = unit.convert_from("deg", 5)
    taper_ratio = 0.25
    rear_spar_ratio = 0.7

    tip_toc = 0.10
    kink_toc = tip_toc + 0.01
    root_toc = kink_toc + 0.03

    y_root = 0.5 * fuselage_width
    y_kink = 1.15 * landing_gears_leg_length
    y_tip = 0.5 * span

    phi_100_int_te = max(0.0, 2.0 * (sweep25 - unit.convert_from("deg", 32)))
    tan_phi100 = np.tan(phi_100_int_te)
    a_const = (
        (1 - 0.25 * taper_ratio) * y_kink + 0.25 * taper_ratio * y_root - y_tip
    ) / (0.75 * y_kink + 0.25 * y_root - y_tip)
    b_const = (
        (np.tan(sweep25) - tan_phi100)
        * ((y_tip - y_kink) * (y_kink - y_root))
        / (0.25 * y_root + 0.75 * y_kink - y_tip)
    )
    root_c = (area - b_const * (y_tip - y_root)) / (
        y_root + y_kink + a_const * (y_tip - y_root) + taper_ratio * (y_tip - y_kink)
    )
    kink_c = a_const * root_c + b_const
    tip_c = taper_ratio * root_c

    tan_phi0 = 0.25 * (kink_c - tip_c) / (y_tip - y_kink) + np.tan(sweep25)

    mac = (
        2.0
        * (
            3.0 * y_root * root_c**2
            + (y_kink - y_root) * (root_c**2 + kink_c**2 + root_c * kink_c)
            + (y_tip - y_kink) * (kink_c**2 + tip_c**2 + kink_c * tip_c)
        )
        / (3 * area)
    )

    y_mac = (
        3.0 * root_c * y_root**2
        + (y_kink - y_root)
        * (kink_c * (y_root + y_kink * 2.0) + root_c * (y_kink + y_root * 2.0))
        + (y_tip - y_kink)
        * (tip_c * (y_kink + y_tip * 2.0) + kink_c * (y_tip + y_kink * 2.0))
    ) / (3.0 * area)

    mac_position = (
        (y_kink - y_root)
        * tan_phi0
        * (
            (y_kink - y_root) * (kink_c * 2.0 + root_c)
            + (y_tip - y_kink) * (kink_c * 2.0 + tip_c)
        )
        + (y_tip - y_root) * tan_phi0 * (y_tip - y_kink) * (tip_c * 2.0 + kink_c)
    ) / (3 * area)

    position = fuselage_cabin_center - (
        mac_position + 0.45 * mac
    )  # Set wing root position

    x_root = position
    x_kink = x_root + (y_kink - y_root) * tan_phi0
    x_tip = x_root + (y_tip - y_root) * tan_phi0

    x_mac = x_root + (
        (x_kink - x_root)
        * (
            (y_kink - y_root) * (kink_c * 2.0 + root_c)
            + (y_tip - y_kink) * (kink_c * 2.0 + tip_c)
        )
        + (x_tip - x_root) * (y_tip - y_kink) * (tip_c * 2.0 + kink_c)
    ) / (area * 3.0)

    z_root = 0.0
    z_kink = z_root + (y_kink - y_root) * np.tan(dihedral)
    z_tip = z_root + (y_tip - y_root) * np.tan(dihedral)

    root_loc = np.array([x_root, y_root, z_root])
    kink_loc = np.array([x_kink, y_kink, z_kink])
    tip_loc = np.array([x_tip, y_tip, z_tip])
    np.array([x_mac, y_mac, None])

    2 * (area - fuselage_width * root_c)

    wing_x_root = root_loc[0]
    wing_y_root = root_loc[1]
    wing_z_root = root_loc[2]
    wing_c_root = root_c
    wing_toc_r = root_toc
    wing_x_kink = kink_loc[0]
    wing_y_kink = kink_loc[1]
    wing_z_kink = kink_loc[2]
    wing_c_kink = kink_c
    wing_toc_k = kink_toc
    wing_x_tip = tip_loc[0]
    wing_y_tip = tip_loc[1]
    wing_z_tip = tip_loc[2]
    wing_c_tip = tip_c
    wing_toc_t = tip_toc

    wing_xy = np.array([
        [wing_x_root, wing_y_root],
        [wing_x_tip, wing_y_tip],
        [wing_x_tip + wing_c_tip, wing_y_tip],
        [wing_x_kink + wing_c_kink, wing_y_kink],
        [wing_x_root + wing_c_root, wing_y_root],
        [wing_x_root + wing_c_root, -wing_y_root],
        [wing_x_kink + wing_c_kink, -wing_y_kink],
        [wing_x_tip + wing_c_tip, -wing_y_tip],
        [wing_x_tip, -wing_y_tip],
        [wing_x_root, -wing_y_root],
        [wing_x_root, wing_y_root],
    ])

    wing_yz = np.array([
        [wing_y_root, wing_z_root],
        [wing_y_kink, wing_z_kink],
        [wing_y_tip, wing_z_tip],
        [wing_y_tip, wing_z_tip + wing_toc_t * wing_c_tip],
        [wing_y_kink, wing_z_kink + wing_toc_k * wing_c_kink],
        [wing_y_root, wing_z_root + wing_toc_r * wing_c_root],
        [-wing_y_root, wing_z_root + wing_toc_r * wing_c_root],
        [-wing_y_kink, wing_z_kink + wing_toc_k * wing_c_kink],
        [-wing_y_tip, wing_z_tip + wing_toc_t * wing_c_tip],
        [-wing_y_tip, wing_z_tip],
        [-wing_y_kink, wing_z_kink],
        [-wing_y_root, wing_z_root],
        [wing_y_root, wing_z_root],
    ])

    wing_xz = np.array([
        [wing_x_tip, wing_z_tip + wing_toc_t * wing_c_tip],
        [
            wing_x_tip + 0.1 * wing_c_tip,
            wing_z_tip + wing_toc_t * wing_c_tip - 0.5 * wing_toc_t * wing_c_tip,
        ],
        [
            wing_x_tip + 0.7 * wing_c_tip,
            wing_z_tip + wing_toc_t * wing_c_tip - 0.5 * wing_toc_t * wing_c_tip,
        ],
        [wing_x_tip + wing_c_tip, wing_z_tip + wing_toc_t * wing_c_tip],
        [
            wing_x_tip + 0.7 * wing_c_tip,
            wing_z_tip + wing_toc_t * wing_c_tip + 0.5 * wing_toc_t * wing_c_tip,
        ],
        [
            wing_x_tip + 0.1 * wing_c_tip,
            wing_z_tip + wing_toc_t * wing_c_tip + 0.5 * wing_toc_t * wing_c_tip,
        ],
        [wing_x_tip, wing_z_tip + wing_toc_t * wing_c_tip],
        [wing_x_kink, wing_z_kink + 0.5 * wing_toc_k * wing_c_kink],
        [wing_x_root, wing_z_root + 0.5 * wing_toc_r * wing_c_root],
        [wing_x_root + 0.1 * wing_c_root, wing_z_root],
        [wing_x_root + 0.7 * wing_c_root, wing_z_root],
        [wing_x_root + wing_c_root, wing_z_root + 0.5 * wing_toc_r * wing_c_root],
        [wing_x_kink + wing_c_kink, wing_z_kink + 0.5 * wing_toc_k * wing_c_kink],
        [wing_x_tip + wing_c_tip, wing_z_tip + wing_toc_t * wing_c_tip],
    ])

    contour["wing"] = {"xy": wing_xy, "yz": wing_yz, "xz": wing_xz}

    # Landing gears
    wing_root_loc = root_loc
    wing_root_c = root_c
    wing_kink_loc = kink_loc
    wing_kink_c = kink_c
    wing_rear_spar_ratio = rear_spar_ratio

    y_loc = 1.01 * landing_gears_leg_length
    r = (y_loc - wing_root_loc[1]) / (wing_kink_loc[1] - wing_root_loc[1])
    z_loc = wing_root_loc[2] * (1 - r) + wing_kink_loc[2] * r
    chord = wing_root_c * (1 - r) + wing_kink_c * r
    x_chord = wing_root_loc[0] * (1 - r) + wing_kink_loc[0] * r
    x_loc = x_chord + chord - 1.02 * wing_rear_spar_ratio * wing_kink_c
    attachment_loc = [x_loc, y_loc, z_loc]

    # Nacelles
    wing_root_loc = root_loc
    wing_kink_loc = kink_loc
    wing_kink_c = kink_c
    wing_tip_loc = tip_loc
    wing_tip_c = tip_c
    wing_dihedral = dihedral
    wing_sweep25 = sweep25

    leg_length = landing_gears_leg_length
    leg_attachment_loc = attachment_loc

    nac_engine_slst = slst
    nac_engine_bpr = bpr
    nac_z_ratio = 0.55

    nac_diameter = 0.5 * nac_engine_bpr**0.7 + 5.0e-6 * nac_engine_slst
    nac_length = 0.86 * nac_diameter + nac_engine_bpr**0.37  # statistical regression
    nac_span_position = 0.6 * fuselage_width + 1.4 * nac_diameter

    # INFO: Ground clearence constraint can be realeased
    # by changing wing dihedral and or nacelle span position
    (
        leg_length
        - leg_attachment_loc[2]
        + nac_span_position * np.tan(wing_dihedral)
        - (nac_z_ratio + 0.5) * nac_diameter
    )

    knac = np.pi * nac_diameter * nac_length
    knac * (1.48 - 0.0076 * knac)  # statistical regression, all engines

    tan_phi0 = 0.25 * (wing_kink_c - wing_tip_c) / (
        wing_tip_loc[1] - wing_kink_loc[1]
    ) + np.tan(wing_sweep25)

    y_int = nac_span_position
    x_int = wing_root_loc[0] + (y_int - wing_root_loc[1]) * tan_phi0 - 0.7 * nac_length
    z_int = (
        wing_root_loc[2]
        + (y_int - wing_root_loc[2]) * np.tan(wing_dihedral)
        - nac_z_ratio * nac_diameter
    )

    nac_engine_loc = np.array([x_int, y_int, z_int])

    def get_nacelle_contour(side):
        nac_height = nac_diameter
        nac_width = nac_diameter
        nac_x = nac_engine_loc[0]
        nac_y = nac_engine_loc[1] * side
        nac_z = nac_engine_loc[2]

        section = curve["sec1"]

        nac_xz = np.array([
            [nac_x, nac_z + 0.4 * nac_height],
            [nac_x + 0.1 * nac_length, nac_z + 0.5 * nac_height],
            [nac_x + 0.5 * nac_length, nac_z + 0.5 * nac_height],
            [nac_x + nac_length, nac_z + 0.3 * nac_height],
            [nac_x + nac_length, nac_z - 0.3 * nac_height],
            [nac_x + 0.5 * nac_length, nac_z - 0.5 * nac_height],
            [nac_x + 0.1 * nac_length, nac_z - 0.5 * nac_height],
            [nac_x, nac_z - 0.4 * nac_height],
            [nac_x, nac_z + 0.4 * nac_height],
        ])

        nac_xy = np.array([
            [nac_x, nac_y + 0.4 * nac_width],
            [nac_x + 0.1 * nac_length, nac_y + 0.5 * nac_width],
            [nac_x + 0.5 * nac_length, nac_y + 0.5 * nac_width],
            [nac_x + nac_length, nac_y + 0.3 * nac_width],
            [nac_x + nac_length, nac_y - 0.3 * nac_width],
            [nac_x + 0.5 * nac_length, nac_y - 0.5 * nac_width],
            [nac_x + 0.1 * nac_length, nac_y - 0.5 * nac_width],
            [nac_x, nac_y - 0.4 * nac_width],
            [nac_x, nac_y + 0.4 * nac_width],
        ])

        d_nac_yz = np.stack(
            [
                section[0:, 0] * nac_width,
                section[0:, 1] * nac_height,
                section[0:, 2] * nac_height,
            ],
            axis=1,
        )

        d_fan_yz = np.stack(
            [
                section[0:, 0] * 0.80 * nac_width,
                section[0:, 1] * 0.80 * nac_height,
                section[0:, 2] * 0.80 * nac_height,
            ],
            axis=1,
        )

        nac_yz = np.vstack([
            np.stack([nac_y + d_nac_yz[0:, 0], nac_z + d_nac_yz[0:, 1]], axis=1),
            np.stack([nac_y + d_nac_yz[::-1, 0], nac_z + d_nac_yz[::-1, 2]], axis=1),
        ])

        disk_yz = np.vstack([
            np.stack([nac_y + d_fan_yz[0:, 0], nac_z + d_fan_yz[0:, 1]], axis=1),
            np.stack([nac_y + d_fan_yz[::-1, 0], nac_z + d_fan_yz[::-1, 2]], axis=1),
        ])

        return {"xy": nac_xy, "yz": nac_yz, "xz": nac_xz, "disk": disk_yz}

    # HTP
    fuselage_length = body_length
    fuselage_width = body_width
    wing_position = position
    wing_mac_position = mac_position
    wing_mac = mac

    htp_area = 0.20 * area
    htp_aspect_ratio = 5
    htp_taper_ratio = 0.4
    htp_toc_ratio = 0.10
    htp_sweep25 = unit.convert_from("deg", 30)
    htp_dihedral = unit.convert_from("deg", 5)

    htp_span = np.sqrt(htp_area * htp_aspect_ratio)
    htp_axe_c = (2 / htp_span) * (htp_area / (1 + htp_taper_ratio))
    htp_tip_c = htp_taper_ratio * htp_axe_c
    htp_mac = (
        (2 / 3)
        * htp_axe_c
        * (1 + htp_taper_ratio - htp_taper_ratio / (1 + htp_taper_ratio))
    )

    chord_gradient = 2 * (htp_tip_c - htp_axe_c) / htp_span
    tan_sweep0 = np.tan(htp_sweep25) - 0.25 * chord_gradient
    htp_mac_position = (
        (1 / 3)
        * (htp_span / 2)
        * ((1 + 2 * htp_taper_ratio) / (1 + htp_taper_ratio))
        * tan_sweep0
    )

    htp_position = fuselage_length - 1.30 * htp_axe_c
    (htp_position + htp_mac_position + 0.25 * htp_mac) - (
        wing_position + wing_mac_position + 0.25 * wing_mac
    )

    y_axe = 0.0
    y_tip = 0.5 * htp_span

    z_axe = 0.80 * fuselage_width
    z_tip = z_axe + y_tip * np.tan(htp_dihedral)

    x_axe = htp_position
    x_tip = x_axe + 0.25 * (htp_axe_c - htp_tip_c) + y_tip * np.tan(htp_sweep25)

    htp_axe_loc = np.array([float(x_axe), y_axe, z_axe])
    htp_tip_loc = np.array([x_tip, y_tip, z_tip])

    htp_span = htp_span
    htp_dihedral = htp_dihedral
    htp_t_o_c = htp_toc_ratio
    htp_x_axe = htp_axe_loc[0]
    htp_z_axe = htp_axe_loc[2]
    htp_c_axe = htp_axe_c
    htp_x_tip = htp_tip_loc[0]
    htp_z_tip = htp_tip_loc[2]
    htp_c_tip = htp_tip_c

    htp_xy = np.array([
        [htp_x_axe, 0],
        [htp_x_tip, 0.5 * htp_span],
        [htp_x_tip + htp_c_tip, 0.5 * htp_span],
        [htp_x_axe + htp_c_axe, 0],
        [htp_x_tip + htp_c_tip, -0.5 * htp_span],
        [htp_x_tip, -0.5 * htp_span],
        [htp_x_axe, 0],
    ])

    htp_xz = np.array([
        [htp_x_tip, htp_z_tip],
        [htp_x_tip + 0.1 * htp_c_tip, htp_z_tip + 0.5 * htp_t_o_c * htp_c_tip],
        [htp_x_tip + 0.7 * htp_c_tip, htp_z_tip + 0.5 * htp_t_o_c * htp_c_tip],
        [htp_x_tip + htp_c_tip, htp_z_tip],
        [htp_x_tip + 0.7 * htp_c_tip, htp_z_tip - 0.5 * htp_t_o_c * htp_c_tip],
        [htp_x_tip + 0.1 * htp_c_tip, htp_z_tip - 0.5 * htp_t_o_c * htp_c_tip],
        [htp_x_tip, htp_z_tip],
        [htp_x_axe, htp_z_axe],
        [htp_x_axe + 0.1 * htp_c_axe, htp_z_axe - 0.5 * htp_t_o_c * htp_c_axe],
        [htp_x_axe + 0.7 * htp_c_axe, htp_z_axe - 0.5 * htp_t_o_c * htp_c_axe],
        [htp_x_axe + htp_c_axe, htp_z_axe],
        [htp_x_tip + htp_c_tip, htp_z_tip],
        [htp_x_tip + 0.7 * htp_c_tip, htp_z_tip - 0.5 * htp_t_o_c * htp_c_tip],
        [htp_x_tip + 0.1 * htp_c_tip, htp_z_tip - 0.5 * htp_t_o_c * htp_c_tip],
        [htp_x_tip, htp_z_tip],
    ])

    htp_yz = np.array([
        [0, htp_z_axe],
        [0.5 * htp_span, htp_z_axe + 0.5 * htp_span * np.tan(htp_dihedral)],
        [
            0.5 * htp_span,
            htp_z_axe + 0.5 * htp_span * np.tan(htp_dihedral) - htp_t_o_c * htp_c_tip,
        ],
        [0, htp_z_axe - htp_t_o_c * htp_c_axe],
        [
            -0.5 * htp_span,
            htp_z_axe + 0.5 * htp_span * np.tan(htp_dihedral) - htp_t_o_c * htp_c_tip,
        ],
        [-0.5 * htp_span, htp_z_axe + 0.5 * htp_span * np.tan(htp_dihedral)],
        [0, htp_z_axe],
    ])

    contour["htp"] = {"xy": htp_xy, "yz": htp_yz, "xz": htp_xz}

    # VTP
    fuselage_width = body_width
    wing_position = position
    wing_mac_position = mac_position
    wing_mac = mac

    vtp_toc_ratio = 0.1
    vtp_aspect_ratio = 1.7
    vtp_taper_ratio = 0.4
    vtp_sweep25 = unit.convert_from("deg", 30)
    vtp_area = 0.17 * area

    vtp_height = np.sqrt(vtp_area * vtp_aspect_ratio)
    vtp_root_c = (2 / vtp_height) * (vtp_area / (1 + vtp_taper_ratio))
    vtp_tip_c = vtp_taper_ratio * vtp_root_c
    vtp_mac = (
        (2 / 3)
        * vtp_root_c
        * (1 + vtp_taper_ratio - vtp_taper_ratio / (1 + vtp_taper_ratio))
    )

    chord_gradient = 2 * (vtp_tip_c - vtp_root_c) / vtp_height
    tan_sweep0 = np.tan(vtp_sweep25) - 0.25 * chord_gradient
    vtp_mac_position = (
        (1 / 3)
        * (vtp_height / 2)
        * ((1 + 2 * vtp_taper_ratio) / (1 + vtp_taper_ratio))
        * tan_sweep0
    )

    vtp_position = htp_position - 0.35 * vtp_root_c
    (vtp_position + vtp_mac_position + 0.25 * vtp_mac) - (
        wing_position + wing_mac_position + 0.25 * wing_mac
    )

    x_root = vtp_position
    x_tip = x_root + 0.25 * (vtp_root_c - vtp_tip_c) + vtp_height * np.tan(vtp_sweep25)

    y_root = 0.0
    y_tip = 0.0

    z_root = fuselage_width
    z_tip = z_root + vtp_height

    vtp_root_loc = np.array([x_root, y_root, z_root])
    vtp_tip_loc = np.array([x_tip, y_tip, z_tip])

    vtp_t_o_c = vtp_toc_ratio
    vtp_x_root = vtp_root_loc[0]
    vtp_y_root = vtp_root_loc[1]
    vtp_z_root = vtp_root_loc[2]
    vtp_c_root = vtp_root_c
    vtp_x_tip = vtp_tip_loc[0]
    vtp_y_tip = vtp_tip_loc[1]
    vtp_z_tip = vtp_tip_loc[2]
    vtp_c_tip = vtp_tip_c

    vtp_xz = np.array([
        [vtp_x_root, vtp_z_root],
        [vtp_x_tip, vtp_z_tip],
        [vtp_x_tip + vtp_c_tip, vtp_z_tip],
        [vtp_x_root + vtp_c_root, vtp_z_root],
        [vtp_x_root, vtp_z_root],
    ])

    vtp_xy = np.array([
        [vtp_x_root, vtp_y_root],
        [vtp_x_root + 0.1 * vtp_c_root, vtp_y_root + 0.5 * vtp_t_o_c * vtp_c_root],
        [vtp_x_root + 0.7 * vtp_c_root, vtp_y_root + 0.5 * vtp_t_o_c * vtp_c_root],
        [vtp_x_root + vtp_c_root, vtp_y_root],
        [vtp_x_root + 0.7 * vtp_c_root, vtp_y_root - 0.5 * vtp_t_o_c * vtp_c_root],
        [vtp_x_root + 0.1 * vtp_c_root, vtp_y_root - 0.5 * vtp_t_o_c * vtp_c_root],
        [vtp_x_root, vtp_y_root],
        [vtp_x_tip, vtp_y_tip],
        [vtp_x_tip + 0.1 * vtp_c_tip, vtp_y_tip + 0.5 * vtp_t_o_c * vtp_c_tip],
        [vtp_x_tip + 0.7 * vtp_c_tip, vtp_y_tip + 0.5 * vtp_t_o_c * vtp_c_tip],
        [vtp_x_tip + vtp_c_tip, vtp_y_tip],
        [vtp_x_tip + 0.7 * vtp_c_tip, vtp_y_tip - 0.5 * vtp_t_o_c * vtp_c_tip],
        [vtp_x_tip + 0.1 * vtp_c_tip, vtp_y_tip - 0.5 * vtp_t_o_c * vtp_c_tip],
        [vtp_x_tip, vtp_y_tip],
    ])

    vtp_yz = np.array([
        [vtp_y_root + 0.5 * vtp_t_o_c * vtp_c_root, vtp_z_root],
        [vtp_y_tip + 0.5 * vtp_t_o_c * vtp_c_tip, vtp_z_tip],
        [vtp_y_tip - 0.5 * vtp_t_o_c * vtp_c_tip, vtp_z_tip],
        [vtp_y_root - 0.5 * vtp_t_o_c * vtp_c_root, vtp_z_root],
        [vtp_y_root + 0.5 * vtp_t_o_c * vtp_c_root, vtp_z_root],
    ])

    contour["vtp"] = {"xy": vtp_xy, "yz": vtp_yz, "xz": vtp_xz}

    # Draw components
    # Discipline----------------------------------------

    for typ in ["body", "wing", "htp", "vtp"]:
        data = contour[typ]
        for view in ["xy", "yz", "xz"]:
            plt.fill(
                ref[view][0] + data[view][0:, 0],
                ref[view][1] + data[view][0:, 1],
                color="white",
                zorder=zframe[view][typ],
            )  # draw mask
            plt.plot(
                ref[view][0] + data[view][0:, 0],
                ref[view][1] + data[view][0:, 1],
                color="grey",
                zorder=zframe[view][typ],
            )  # draw contour

    # Draw nacelles
    # ---------------------------------------------------------
    #                                  top        front     side
    znac = {"xy": l0w, "yz": l4, "xz": high}

    nacelle = get_nacelle_contour(side=1)
    for view in ["xy", "yz", "xz"]:
        plt.fill(
            ref[view][0] + nacelle[view][0:, 0],
            ref[view][1] + nacelle[view][0:, 1],
            color="white",
            zorder=znac[view],
        )  # draw mask
        plt.plot(
            ref[view][0] + nacelle[view][0:, 0],
            ref[view][1] + nacelle[view][0:, 1],
            color="grey",
            zorder=znac[view],
        )  # draw contour
    plt.plot(
        ref["yz"][0] + nacelle["disk"][0:, 0],
        ref["yz"][1] + nacelle["disk"][0:, 1],
        color="grey",
        zorder=znac["yz"],
    )  # draw contour

    nacelle = get_nacelle_contour(side=-1)
    for view in ["xy", "yz", "xz"]:
        plt.fill(
            ref[view][0] + nacelle[view][0:, 0],
            ref[view][1] + nacelle[view][0:, 1],
            color="white",
            zorder=znac[view],
        )  # draw mask
        plt.plot(
            ref[view][0] + nacelle[view][0:, 0],
            ref[view][1] + nacelle[view][0:, 1],
            color="grey",
            zorder=znac[view],
        )  # draw contour
    plt.plot(
        ref["yz"][0] + nacelle["disk"][0:, 0],
        ref["yz"][1] + nacelle["disk"][0:, 1],
        color="grey",
        zorder=znac["yz"],
    )  # draw contour

    plt.ylabel("(m)")
    plt.xlabel("(m)")

    save_show_figure(plt.gcf(), show, file_path if save else "")


def pack_data():  # noqa: E501
    """Define the dictionary to pack the model values.

    The dictionary is retrieved as a string.

    Args:
        None

    Returns:
        Dictionary defined as a string

    """
    return "{'slst':[slst,'kN'], 'bpr':[bpr,'nd'],\
         'area':[area,'m2'], 'span':[span,'m'],\
             'ar':[ar,'nd'], 'length':[length,'m'],\
             'engine_type':[engine_type,'string'],\
             'fuel_type':[fuel_type,'string'], 'gi':[gi,'nd'],\
             'tkl':[tkl,'m'], 'tkv':[tkv,'m3'], 'n_pax':[n_pax,'int'],\
             'design_range':[design_range,'km'],\
             'mtom_in':[mtom_in,'kg'], 'mzfm_in':[mzfm_in,'kg'],\
             'mtom_out':[mtom_out,'kg'], 'mzfm_out':[mzfm_out,'kg'],\
             'mlm':[mlm,'kg'], 'mfm':[mfm,'kg'],\
             'oem':[oem,'kg'], 'total_fuel':[total_fuel,'kg'],\
             'm_engine':[m_engine,'kg'],\
             'm_tank':[m_tank,'kg'], 'fm':[fm,'%'], 'bed':[bed,'Wh/kg'],\
             'total_enrg':[total_enrg,'kWh'], 'mbm':[mbm,'kg'],\
             'm_battery':[m_battery,'kg'],\
             'm_fuel_cell':[m_fuel_cell,'kg'],\
             'payload':[payload,'kg'], 'payload_max':[payload_max,'kg'],\
             'tofl':[tofl,'m'],\
             'vapp':[vapp,'kt'], 'vz':[vz,'ft/min'],\
             'sfc':[sfc,'kg/h/daN'], 'sec':[sec,'kW/daN'],\
             'fn_ton':[fn_ton,'daN'],\
             'fn_mcl':[fn_mcl,'daN'],\
             'cx0':[cx0,'nd'], 'ki':[ki,'nd'], 'cl_max_to':[cl_max_to,'nd'],\
             'cl_max_ld':[cl_max_ld,'nd'],\
             'coc':[coc,'$/trip'], 'doc':[doc,'$/trip'], }"
